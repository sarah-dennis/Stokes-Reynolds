#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jan 22 14:59:46 2024

@author: sarahdennis
"""
import csv
import time
import numpy as np

from scipy.sparse.linalg import bicgstab
from scipy.sparse.linalg import splu

from scipy.interpolate import interpn
from scipy.signal import argrelextrema as relEx

import graphics
import stokes_solvers as solver

bicgstab_rtol = 1e-8

plot_mod = 50
write_mod = 50
error_mod = 100

import stokes_examples as examples

#------------------------------------------------------------------------------
def run_new(N, iters):
    tri = examples.biswasEx(N)
    # tri = examples.zeroReynEx(N)

    nm = tri.Nx * tri.Ny

    u_init = np.zeros(nm)
    v_init = np.zeros(nm)
    psi_init = np.zeros(nm)
    past_iters = 0

    # u, v, psi = run(tri, u_init, v_init, psi_init, iters, past_iters)
    u, v, psi = run_spLU(tri, u_init, v_init, psi_init, iters, past_iters)
    
    psi = solver.unmirror_boundary(tri, psi)
    write_solution(tri.filename+".csv", nm, u, v, psi, iters)
                                                                                                                                                                                                                                                                             
def run_load(N, iters):
    tri = examples.biswasEx(N)
    # tri = examples.zeroReynEx(N)

    u, v, psi, past_iters = read_solution(tri.filename+".csv", tri.Nx*tri.Ny)
    
    # u, v, psi = run(tri, u, v, psi, iters, past_iters)
    u, v, psi = run_spLU(tri, u, v, psi, iters, past_iters)
    
    psi = solver.unmirror_boundary(tri, psi)
    write_solution(tri.filename+".csv", tri.Nx*tri.Ny, u, v, psi, iters+past_iters)


def load_scale(N_load, N_new):
    tri_load = examples.biswasEx(N_load)
    points_load = (tri_load.ys, tri_load.xs)
    
    u_load, v_load, psi_load, past_iters = read_solution(tri_load.filename+".csv", tri_load.Ny*tri_load.Nx)
    u_load_2D = u_load.reshape((tri_load.Ny,tri_load.Nx), order='F')
    v_load_2D = v_load.reshape((tri_load.Ny,tri_load.Nx), order='F')
    psi_load_2D = psi_load.reshape((tri_load.Ny,tri_load.Nx), order='F')


    tri_scale = examples.biswasEx(N_new)
    points_scale = np.meshgrid(tri_scale.ys, tri_scale.xs)
    
    u_scaled_2D = interpn(points_load, u_load_2D, tuple(points_scale), method='linear')
    v_scaled_2D = interpn(points_load, v_load_2D, tuple(points_scale), method='linear')
    psi_scaled_2D = interpn(points_load, psi_load_2D, tuple(points_scale), method='linear')

    u_scaled = u_scaled_2D.ravel()
    v_scaled = v_scaled_2D.ravel()
    psi_scaled = psi_scaled_2D.ravel()

    write_solution(tri_scale.filename+".csv", tri_scale.Ny*tri_scale.Nx, u_scaled, v_scaled, psi_scaled, 0)
    plot_load(N_new)
    
def plot_load(N):
    tri = examples.biswasEx(N)
    # tri = examples.zeroReynEx(N)
    u, v, psi, past_iters = read_solution(tri.filename+".csv", tri.Nx * tri.Ny)

    make_plots(tri, u, v, psi, past_iters)

#------------------------------------------------------------------------------
def read_solution(filename, nm):
    u = np.zeros(nm)
    v = np.zeros(nm)
    psi = np.zeros(nm)
    with open(filename, newline='') as file:
        reader = csv.reader(file)

        for i in range(nm):
            line = next(reader)
            ui, vi, psii = line[0].split(' ')
            u[i] = float(ui)
            v[i] = float(vi)
            psi[i] = float(psii)
        past_iters = int(next(reader)[0])
        file.close()
    return u, v, psi, past_iters

def write_solution(filename, nm, u, v, psi, iters):

    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file, delimiter=' ')
        for i in range(nm):
            writer.writerow([u[i], v[i], psi[i]])
        
        writer.writerow([iters])
        print("  saved csv")
        file.close()    

#------------------------------------------------------------------------------
def run(tri, u, v, past_psi, iters, past_iters):
    
    M = solver.Dpsi_linOp(tri)
    
    for i in range(iters): 
        
        t0 = time.time()
        rhs = solver.update_rhs(tri, u, v)
        
        psi, exit_flag = bicgstab(M, rhs, tol=bicgstab_rtol)
        
        u, v = solver.uv_approx(tri, u, v, psi)
        
        psi = solver.mirror_boundary(tri, psi)

        tf = time.time()
        if i % error_mod == 0: 
            past_psi = solver.unmirror_boundary(tri, past_psi)
            psi = solver.unmirror_boundary(tri, psi)
            
            err_i = np.max(np.abs(psi - past_psi))
            
            print("k=%d of %d"%(i+past_iters+1, iters+past_iters))
            print("  time: %.3f s"%(tf-t0))
            print("  error: %.5e psi"%err_i)
            
            if err_i < bicgstab_rtol:
                print('warning: lower bicgstab_rtol')
            
        if i % plot_mod == 0:
            psi = solver.psi_unmirror_boundary(tri, psi)
            make_plots(tri, u, v, psi, i+1 + past_iters)
        
        if i % write_mod == 0:
            psi = solver.unmirror_boundary(tri, psi)
            write_solution(tri.filename, tri.Nx*tri.Ny, u, v, psi, i+1+past_iters)


        past_psi = psi

    return u, v, psi

def run_spLU(tri, u, v, past_psi, iters, past_iters):
    
    M = solver.Dpsi_cscmatrixBuild(tri)
    LU = splu(M)
    
    for i in range(iters): 
        
        t0 = time.time()
        rhs = solver.update_rhs(tri, u, v)

        psi = LU.solve(rhs)
        
        u, v = solver.uv_approx(tri, u, v, psi)
        
        psi = solver.mirror_boundary(tri, psi)
        
        tf = time.time()
        
        if i % error_mod == 0: 
            past_psi = solver.unmirror_boundary(tri, past_psi)
            psi = solver.unmirror_boundary(tri, psi)
            
            err_i = np.max(np.abs(psi - past_psi))
            
            print("k=%d of %d"%(i+past_iters+1, iters+past_iters))
            print("  time: %.3f s"%(tf-t0))
            print("  error: %.5e psi"%err_i)
            
        if i % plot_mod == 0:
            psi = solver.unmirror_boundary(tri, psi)
            make_plots(tri, u, v, psi, i+1 + past_iters)
        
        if i % write_mod == 0:
            psi = solver.unmirror_boundary(tri, psi)
            write_solution(tri.filename+".csv", tri.Nx*tri.Ny, u, v, psi, i+1+past_iters)


        past_psi = psi

    return u, v, psi



#------------------------------------------------------------------------------
# PLOTTING 
#------------------------------------------------------------------------------
def make_plots(tri, u, v, stream, iters):
    n = tri.Nx
    m = tri.Ny

# Grid domain
    xs = tri.xs
    ys = tri.ys

# Stream: Psi(x,y) heat & contour
    stream_2D = stream.reshape((m,n))
    ax_labels = ['$\psi(x,y)$ : $u = \psi_y$, $v = \psi_x$', '$x$', '$y$']
    title = 'Stream ($N=%d$, $k=%d$)'%(tri.N, iters)
    graphics.plot_contour_heat(stream_2D, xs, ys, title, ax_labels)
      
#  Velocity: (U, V)  streamplot
    u_2D = u.reshape((m,n))
    v_2D = v.reshape((m,n))
    
    ax_labels = ['$|(u,v)|_2$','$x$', '$y$']
    title = 'Velocity ($N=%d$, $k=%d$)'%(tri.N, iters)
    ax_labels = ['$\psi(x,y)$ : $u = \psi_y$, $v = \psi_x$','$x$', '$y$']
    graphics.plot_stream_heat(u_2D, v_2D, xs, ys, stream_2D, title, ax_labels)
    # plot_stream(u_2D, v_2D, xs, ys, title, ax_labels)

#  Vorticity: w = vx - uy heat & contour
    uy_2D = np.gradient(u_2D, tri.dx, axis=0)
    vx_2D = np.gradient(v_2D, tri.dx, axis=1)
    w = np.zeros((m,n))
    for j in range(m):
        for i in range(n):   
            w[j,i] = vx_2D[j,i] - uy_2D[j,i]
    ax_labels = ['$\omega(x,y) = -( \psi_{xx} + \psi_{yy})$', '$x$', '$y$']
    title = 'Vorticity ($N=%d$, $k=%d$)'%(tri.N, iters)
    graphics.plot_contour_heat(w, xs, ys, title, ax_labels)


#------------------------------------------------------------------------------
# Critiacal points 
#------------------------------------------------------------------------------

def get_boundary(tri, psi):
    n = tri.Nx
    m = tri.Ny
    
    i_mid = n//2
    
    left = np.zeros((m,3)) # x, y, psi
    right = np.zeros((m,3)) 
    
    
    for j in range(m):
        
        y = tri.y0 + j*tri.dx
        
        dj = j % tri.slope
        di = int(j//tri.slope) 
        
        if dj == 0: #true boundary points
            k_left = j*n + i_mid - di 
            k_right = j*n + i_mid + di
        else: #interior boundary points
            k_left = j*n + i_mid - di + 1  
            k_right = j*n + i_mid + di - 1
        
        x_left = (i_mid - di + 1)*tri.dx + tri.x0
        x_right = tri.xf - (i_mid - di - 1)*tri.dx
        
        left[j] = [x_left, y, psi[k_left]]
        right[j] = [x_right, y, psi[k_right]]
        
    return left, right

def get_center(tri, psi):
    n = tri.Nx 
    m = tri.Ny 
    
    i_mid = n//2
    x = i_mid * tri.dx+ tri.x0
    
    center = np.zeros((m,3)) # x, y, psi
    
    for j in range(m):
        
        y = tri.y0 + j*tri.dx
        
        k = j*n + i_mid
        
        center[j] = [x, y, psi[k]]
        
    return center


def get_criticals(N):
    tri = examples.biswasEx(N)
    u, v, psi, past_iters = read_solution(tri.filename+".csv", tri.Nx * tri.Ny)
    
    left, right = get_boundary(tri, psi)
    center = get_center(tri, psi)
    
    left_signs = []
    right_signs = []
    
    center_maxs = []
    center_mins = []
    max_inds = relEx(center[:,2], np.greater)[0]
    min_inds = relEx(center[:,2], np.less)[0]
    
    for i in max_inds:
        x,y,p = center[i]
        # print("(x:%.1f, y:%.6f) p=%.5e"% (x,y,p))
        center_maxs.append([x,y,p])
    

    for i in min_inds:
        x,y,p = center[i]
        # print("(x:%.1f, y:%.6f) p=%.5e"% (x,y,p))
        center_mins.append([x,y,p])
    
    sign_ref = 0
    for (x, y, p) in left:
        sign_new = np.sign(p)
        if sign_new != 0 and sign_new != sign_ref:
            sign_ref = sign_new
            left_signs.append([x,y])

    sign_ref = 0
    for (x, y, p) in right:
        sign_new = np.sign(p)
        if sign_new != 0 and sign_new != sign_ref:
            sign_ref = sign_new
            right_signs.append([x,y])
    
    center_maxs.reverse()
    center_mins.reverse()
    left_signs.reverse()
    right_signs.reverse()
    
    return center_maxs, center_mins, left_signs, right_signs
    
def write_criticals(N):
    maxs, mins, left, right = get_criticals(N)
    
    crits_filename = 'crits_stokes_N%d.csv'%N 
    with open (crits_filename,'w', newline='') as file:
        writer = csv.writer(file, delimiter=' ')

        writer.writerow('xy')
        for (x, y) in left:
            writer.writerow([x,y])
                
        writer.writerow('xy')
        for (x, y) in right:
            writer.writerow([x,y])

        writer.writerow('xyp')
        for (x, y, p) in maxs:
            writer.writerow([x,y,p])
            
        writer.writerow('xyp')
        for (x, y, p) in mins:
            writer.writerow([x,y,p])


def compare_N(Ns, N_max): #Ns: [44, 120, 240, 512, 1000]
    tru_maxs, tru_mins, tru_left, tru_right = get_criticals(N_max)
    
    M = len(Ns)
    a = len(tru_maxs)
    b = len(tru_mins)
    c = len(tru_left)
    d = len(tru_right)
    
    err_maxs = np.zeros((M, a))
    err_mins = np.zeros((M, b))
    err_left = np.zeros((M, c))
    err_right = np.zeros((M, d))
    
    for i in range(M):
        N = Ns[i]
        
        N_maxs, N_mins,  N_left, N_right = get_criticals(N)
        
        for j in range(a):
            if j < len(N_maxs): #[2] = psi
                err_maxs[i, j] = tru_maxs[j][2] - N_maxs[j][2]
            else:
                err_maxs[i, j] = tru_maxs[j][2]
        
        for j in range(b):
            if j < len(N_mins): 
                err_mins[i, j] = tru_mins[j][2] - N_mins[j][2]
            else:
                err_mins[i, j] = tru_mins[j][2]
            
        for j in range(c):
            if j < len(N_maxs): #[1] = y
                err_left[i, j] = tru_left[j][1] - N_left[j][1]
            else:
                err_left[i, j] = tru_left[j][1]
        
        for j in range(d):
            if j < len(N_mins):
                err_right[i, j] = tru_right[j][1] - N_right[j][1]
            else:
                err_right[i, j] = tru_right[j][1]
        
    return err_maxs, err_mins, err_left, err_right
        
        
        
        
        
        